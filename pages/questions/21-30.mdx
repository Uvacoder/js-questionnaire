import Question from '../../components/Question.tsx'
import Answer from '../../components/Answer.tsx'

# Q. 21-30

### 21. What's the value of sum?

<Question render={
  <Answer answer="A">
  <Answer.Option>A: 105</Answer.Option>
  <Answer.Option>B: "105"</Answer.Option>
  <Answer.Option>C: TypeError</Answer.Option>
  <Answer.Option>D: "10*10+5"</Answer.Option>
</Answer>
}>

```javascript
const sum = eval('10*10+5')
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>
<p>

<h3>Answer: A</h3>

`eval` evaluates codes that's passed as a string. If it's an expression, like in this case, it evaluates the expression. The expression is `10 * 10 + 5`. This returns the number `105`.

</p>
</details>

---

### 22. How long is cool_secret accessible?

<Question render={
  <Answer answer="B">
  <Answer.Option>A: Forever, the data doesn't get lost.</Answer.Option>
  <Answer.Option>B: When the user closes the tab.</Answer.Option>
  <Answer.Option>C: When the user closes the entire browser, not only the tab.</Answer.Option>
  <Answer.Option>D: When the user shuts off their computer.</Answer.Option>
</Answer>
}>

```javascript
sessionStorage.setItem('cool_secret', 123)
```

</Question>

<details>
        <summary>
        <b>ðŸ’¡ Answer</b>
    </summary>
<p>

<h3>Answer: B</h3>

The data stored in `sessionStorage` is removed after closing the _tab_.

If you used `localStorage`, the data would've been there forever, unless for example `localStorage.clear()` is invoked.

</p>
</details>

---

### 23. What's the output?

<Question render={
  <Answer answer="B">
  <Answer.Option>A: 8</Answer.Option>
  <Answer.Option>B: 10</Answer.Option>
  <Answer.Option>C: SyntaxError</Answer.Option>
  <Answer.Option>D: ReferenceError</Answer.Option>
</Answer>
}>

```javascript
var num = 8
var num = 10

console.log(num)
```

</Question>

<details>
        <summary>
        <b>ðŸ’¡ Answer</b>
    </summary>

<p>

<h3>Answer: B</h3>

With the `var` keyword, you can declare multiple variables with the same name. The variable will then hold the latest value.

You cannot do this with `let` or `const` since they're block-scoped.

</p>
</details>

---

### 24. What's the output?

<Question render={
  <Answer answer="C">
  <Answer.Option>A: false true false true</Answer.Option>
  <Answer.Option>B: false true true true</Answer.Option>
  <Answer.Option>C: true true false true</Answer.Option>
  <Answer.Option>D: true true true true</Answer.Option>
</Answer>
}>

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' }
const set = new Set([1, 2, 3, 4, 5])

obj.hasOwnProperty('1')
obj.hasOwnProperty(1)
set.has('1')
set.has(1)
```

</Question>

<details>
       <summary>
        <b>ðŸ’¡ Answer</b>
    </summary>
<p>

<h3>Answer: C</h3>

All object keys (excluding Symbols) are strings under the hood, even if you don't type it yourself as a string. This is why `obj.hasOwnProperty('1')` also returns true.

It doesn't work that way for a set. There is no `'1'` in our set: `set.has('1')` returns `false`. It has the numeric type `1`, `set.has(1)` returns `true`.

</p>
</details>

---

### 25. What's the output?

<Question render={
  <Answer answer="C">
  <Answer.Option>{'A: { a: "one", b: "two" }'}</Answer.Option>
  <Answer.Option>{'B: { b: "two", a: "three" }'}</Answer.Option>
  <Answer.Option>{'C: { a: "three", b: "two" }'}</Answer.Option>
  <Answer.Option>{'D: SyntaxError'}</Answer.Option>
</Answer>
}>

```javascript
const obj = { a: 'one', b: 'two', a: 'three' }
console.log(obj)
```

</Question>

<details>
           <summary>
        <b>ðŸ’¡ Answer</b>
    </summary>
<p>

<h3>Answer: C</h3>

If you have two keys with the same name, the key will be replaced. It will still be in its first position, but with the last specified value.

</p>
</details>
